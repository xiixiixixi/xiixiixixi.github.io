<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiixiixixi.github.io</id>
    <title>Gridea</title>
    <updated>2021-04-17T17:10:46.982Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiixiixixi.github.io"/>
    <link rel="self" href="https://xiixiixixi.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://xiixiixixi.github.io/images/avatar.png</logo>
    <icon>https://xiixiixixi.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[比特币数据结构]]></title>
        <id>https://xiixiixixi.github.io/post/bi-te-bi-shu-ju-jie-gou/</id>
        <link href="https://xiixiixixi.github.io/post/bi-te-bi-shu-ju-jie-gou/">
        </link>
        <updated>2021-04-17T17:09:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="哈希指针">哈希指针</h1>
<ul>
<li>指针<br>
在程序运行过程中，需要用到数据。最简单的是直接获取数据，但当数据本身较大，需要占用较大空间时，明显会造成一定麻烦。因此，可以引入<strong>指针</strong>这一概念。当需要获取数据时，只需要按照指针所给的地址，去对应的位置读取数据即可，这样大大节省了内存空间。<br>
在实际中，为了便于程序移植性等原因，指针实际上存储的是<strong>逻辑地址</strong>而非物理地址。</li>
</ul>
<blockquote>
<p>区块链结构本身为一条链表，节点为区块。而传统链表实现，便是通过指针将各个节点串联起来而称为最终的链。如下便是我们最常见的一个链表：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/xiixiixixi/picgo/raw/master/img/20210418002317.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L011X1hpYW95ZQ==,size_16,color_FFFFFF,t_70" alt="" loading="lazy"></figure>
<p>但在区块链系统中，并未采用指针，而是使用了<strong>哈希指针</strong></p>
</blockquote>
<ul>
<li>
<p>哈希指针<br>
如下图对于该节点，我们可以看到有两个指针指向这个节点（实际上为一个），其中P为该节点的地址，H()为该节点的哈希值，该值与节点中内容有关。当节点（区块）中内容发生改变，该哈希值也会发生改变，从而保证了区块内容不能被篡改。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/xiixiixixi/picgo/raw/master/img/20210418002441.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L011X1hpYW95ZQ==,size_16,color_FFFFFF,t_70" alt="" loading="lazy"></figure>
</li>
</ul>
<blockquote>
<p>在比特币中，其最基本的数据结构便是一个个区块形成的区块链。</p>
</blockquote>
<ul>
<li>区块链与链表区别1：哈希指针代替普通指针<br>
如图为一个简单的区块链。其中，每个区块根据自己的区块内容生成自己的哈希值，此外，每个区块（除创世纪块）都保存有前一个区块的哈希值。需要注意的是，本区块哈希生成依赖于本区块内容，而本区块内容中又包含有前一个区块的哈希值。从而保证了区块内容不被篡改。</li>
</ul>
<blockquote>
<p>如图中所示，如果我们想要破坏区块链完整性。篡改B的内容，而C中保存有B的哈希值，所以C也得进行修改。而同样C后区块也得修改。而用户只需要记住最后一个区块链的哈希地址，就可以检测区块链上内容是否被篡改。<br>
在实际应用中，一整条链可能会被切断分开保存在多个地方。若用户仅仅具有其中一段，当用到前面部分区块数据时，直接问系统中其他节点要即可，当要到之后，仅仅通过计算要到的最后一个哈希值和自己保存哈希值是否一致可以判断所给内容是否确实为区块链上真实的内容。<br>
<img src="https://gitee.com/xiixiixixi/picgo/raw/master/img/20210418002556.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L011X1hpYW95ZQ==,size_16,color_FFFFFF,t_70" alt="" loading="lazy"></p>
</blockquote>
<h2 id="markle-tree默克尔树">Markle Tree(默克尔树)</h2>
<blockquote>
<p>Markle Tree是比特币系统中又一个重要的数据结构<br>
首先，回顾一下Binary Tree(如果不懂请自行复习数据结构)。Markle Tree和Binary Tree的区别有哪些？</p>
</blockquote>
<p>Markle Tree用哈希指针代替了普通指针</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/xiixiixixi/picgo/raw/master/img/20210418002731.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L011X1hpYW95ZQ==,size_16,color_FFFFFF,t_70" alt="" loading="lazy"></figure>
<p>上图即为一个简单的Markle Tree，其中A、B、C、D为数据块。可见，A和B各有一个哈希值，将其合并放在一个节点中，C和D同样操作，而后，针对得到的两个节点分别取哈希，又可以得到两个新的哈希值，即为图中根节点。实际中，在区块块头中存储的是根节点的哈希值（对其再取一次哈希）。<br>
如视频中图片：</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/xiixiixixi/picgo/raw/master/img/20210418003846.png" alt="" loading="lazy"></figure>
<p>该数据结构的优点在于：只需要记住Root Hash（根哈希值），便可以检测出对树中任何部位的修改。<br>
例如，所绘制Markle Tree中节点B发生了改变，则对应的第二层第一个节点中第二个哈希值便也会发生改变，进而根节点中第一个哈希值也会发生改变，从而导致根哈希值也发生了改变。</p>
<blockquote>
<p>在比特币系统中，不同区块通过哈希值指针连接，在同一个区块中的多个交易（数据块），则通过Markle Tree的形式组织在一起。区块本身分为两部分（块头和块身），在块头中存在有根哈希值（没有交易的具体信息），块身中存在交易列表。</p>
</blockquote>
<p><strong>Markle Tree的实际用途</strong><br>
Markle Tree可以用于提供Markle Proof。关于Markle proof，需要先了解比特币系统中节点。比特币中节点分为<strong>轻节点</strong>和<strong>全节点</strong>。全节点保存整个区块的所有内容，而轻节点仅仅保存区块的块头信息。</p>
<blockquote>
<p>为什么要分轻节点和全节点？<br>
因为硬件的局限。一个区块大小为1MB，对于移动便携设备来说，如果存储区块的所有内容，则所需空间过大，而这是不现实的。所以轻节点只需要存储区块块头信息，全节点存储区块所有内容即可。</p>
</blockquote>
<p>当需要向轻节点证明某条交易是否被写入区块链，便需要用到Markle proof。我们将交易到根节点这一条路径称为Markle proof，全节点将整个Markle proof发送给轻节点（如下图所示），轻节点即可根据其算出根哈希值，和自己保存的对比，从而验证该交易是否被写入区块链。只要沿着该路径，所有哈希值都正确，说明内容没有被修改过。<img src="https://gitee.com/xiixiixixi/picgo/raw/master/img/ll-2.png" alt="ll-2" loading="lazy"></p>
<blockquote>
<p>思考：是否存在不安全的情况？如下图我们要验证B，但是H(1)和H(4)都是全节点提供的。全节点可否修改B，通过H(1)调整，使得修改过后的H(1)和轻节点计算出的H(2)一起取得哈希仍然为H(3)<br>
<img src="https://gitee.com/xiixiixixi/picgo/raw/master/img/20210418003154.png" alt="" loading="lazy"><br>
实际上，这种情况为人为制造哈希碰撞。而由于公开课笔记2中可知，由于哈希函数的collision resistance性质，这种情况是不会发生的。从而，保证了系统的不可篡改性。同时，这样一个Markle Proof的事件复杂度为O(log n),非常高效【证明交易存在】。如果要证明交易不存在，如果不对叶节点规定排序顺序，没有一个效率较高的方法证明不存在。<br>
在比特币系统中，没有相应的需求，所以在比特币系统中并没有对Markle Tree进行排序。</p>
</blockquote>
<p>一般来说，一般的链表我们都可以改造为使用哈希指针的链表，但当链表中存在环时，哈希指针便不能再使用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[比特币密码学原理]]></title>
        <id>https://xiixiixixi.github.io/post/bi-te-bi-mi-ma-xue-yuan-li/</id>
        <link href="https://xiixiixixi.github.io/post/bi-te-bi-mi-ma-xue-yuan-li/">
        </link>
        <updated>2021-04-17T16:04:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1密码学的哈希函数">1.密码学的哈希函数</h2>
<h3 id="cryptographic-hash-function密码散列函数">cryptographic hash function（密码散列函数）</h3>
<p><strong>哈希函数满足的条件：</strong></p>
<ol>
<li>可以接收任意长度的字符串作为输入</li>
<li>产生固定长度的输出</li>
<li>高效可计算的，即计算时间在合理范围内</li>
</ol>
<p><strong>三个重要的性质：</strong></p>
<ol>
<li>
<p>collision resistance（抗碰撞性）</p>
<p>哈希碰撞：if x!=y, H(x)=H(y)， 即不同的输入被映射到相同的输出一般来说，哈希碰撞是不可避免的，因为输入空间是远远大于输出空间的，比如256位的hash值，那么输出空间就是 2^256，即所有输出的可能取值，但是输入空间是无限大的，根据抽屉原理（鸽笼原理），必然会有两个输入会被映射到到同一个输出。<br>
所以，collision resistance不是说不会出现哈希碰撞，而是没有高效的方法人为的制造哈希碰撞，只能采取蛮力求解的方法（brute-force）,当输入空间很大时，是不可能的。</p>
<p><strong>用处：</strong></p>
<p>可以用来对消息(message)求摘要H(message)=digest,来检测消息是否被篡改。比如上传文件前，先对文件算摘要digest，文件下载回来时再算摘要digest’，比较两个摘要是否相等来检测文件是否被篡改。</p>
<p><strong>注意：</strong></p>
<p>没有哪一个哈希函数已经在数学上被证明是collision resistance的，有些哈希函数已经被找到人为制造哈希碰撞的方法，比如MD5、SHA-1（王小云教授）</p>
</li>
<li>
<p>hiding（单向的）</p>
<p>给定H(x)，无法求出x，即哈希函数是单向的，不可逆的。当然前提还是输入空间足够大而且分布均匀（即各种取值的可能性是接近的），蛮力求解的方法是不可行的。<br>
实际操作时如果输入空间不够大或者分布不均匀，可以在输入后面拼接一个随机数H(x||nonce)，这里随机数的选取要足够随机。</p>
<p><strong>用处：</strong></p>
<p>结合collision resistance的性质来实现digital commitment(数字承诺)，某个人对某个股票进行涨停预测，我们如何保证能够知晓其预测是否准确？最简单的是提前公布，等待实际结果出现后验证。但实际中，当提前发布预测后，可能会由于预测者本身对股市实际结果造成影响。所以，应该将提前将其写于纸上并密封，交给第三方机构保管，等到实际结果出现后开启密封与实际对比，这就是digital commitment。而第三方机构需要能够使人信服，在实际生活中，有很多场景并不存在一个这样的第三方机构，而区块链技术正为此提供了一个很好的解决方法。</p>
</li>
<li>
<p>puzzle friendly</p>
<p>该性质要求哈希值计算H(x)事先不可预测，仅仅根据输入很难预测出输出。例如：我们需要一个哈希值，存在于某一个范围内，只能通过不停运算查找出来。该性质保证了比特币系统中，只能通过“挖矿”调整nonce，来使得H(block header)≤target获得比特币。也就是说，该性质保证了工作量证明(POW)机制可以运行下去【“挖矿难，但验证易”】。在比特币系统中采用SHA-256哈希函数</p>
</li>
</ol>
<h2 id="2签名">2.签名</h2>
<p>非对称加密体系(asymmetric encryption algorithm)</p>
<img src="https://gitee.com/xiixiixixi/picgo/raw/master/img/20201129100124705.png" alt="img" style="zoom: 100%;" />
<p>在数学上可以用d(c(x))=x，来表示加密解密过程。</p>
<p><strong>公钥和私钥：</strong><br>
私钥： 私钥就是随机选取的一个数而已，可以使用随机数生成器生成，也可以采用手工生成的方式。比如需要一个256位的私钥，那你可以掷硬币256次，记录0和1，将这256位随机得到的二进制数字作为你的私钥。但注意，私钥一定要保持机密，而且最好备份防止意外丢失。<br>
公钥 ：私钥通过一些算法(比如椭圆曲线算法)可以生成公钥，公钥可以公开，实际中无法从公钥中算出私钥。</p>
<p><strong>常用的非对称加密算法：</strong></p>
<ol>
<li>RSA：名字来源于三位科学家的名字，目前应用非常广泛、历史也比较悠久的数字加密和签名技术，支付宝就是通过RSA算法(2048位)来进行签名验证，安全性的保证基于大整数的质因数分解十分困难的原理。</li>
<li>DSA：即Digital Signature Algorithm，数字签名算法，DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。</li>
<li>ECC：Elliptic Curve Cryptography，椭圆曲线加密算法，是基于椭圆曲线数学理论，相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全。据研究，160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密。</li>
</ol>
<p><strong>数字签名过程：</strong><br>
发送报文时，发送方用一个哈希函数从报文文本中生成报文摘要，然后用发送方的私钥对这个摘要进行加密，这个加密后的摘要将作为报文的数字签名和报文一起发送给接收方，接收方首先用与发送方一样的哈希函数从接收到的原始报文中计算出报文摘要，接着再公钥来对报文附加的数字签名进行解密，如果这两个摘要相同、那么接收方就能确认该报文是发送方的。</p>
<p><img src="https://gitee.com/xiixiixixi/picgo/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA4Mzg5OQ==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" loading="lazy">数字签名可以保证信息传输的完整性、确认发送者的身份认证、防止交易中的抵赖发生。</p>
<p><strong>比特币中账户管理：</strong></p>
<p>中心化的账户管理模式：带上证件去第三方机构（比如银行）办理开户手续<br>
比特币的去中心化账户管理模式：每个用户自己决定开户，不需要任何人批准，开户的过程就是创立一个公钥私钥的对，(public key,private key)就代表一个账户，产生两个相同的公私钥对的可能性可以小到忽略不计。<br>
公钥和私钥的应用保证了“签名”的应用。当在比特币网络中进行转账时，通过“签名”可以明确是由哪个账户转出的，从而防止不良分子对其他账户比特币的盗取。<br>
在发布交易时，通过自己私钥签名，其他人可以根据公钥进行验证，从而保证该交易由自己发起。也就是说，只有拥有私钥，才能将该账户中的比特币转走。<br>
【注意：比特币系统中，很难通过生成大量公私钥对来获取他人私钥】</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[开篇大吉，财源滚滚]]></title>
        <id>https://xiixiixixi.github.io/post/kai-pian-da-ji-cai-yuan-gun-gun/</id>
        <link href="https://xiixiixixi.github.io/post/kai-pian-da-ji-cai-yuan-gun-gun/">
        </link>
        <updated>2021-04-14T13:29:19.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://gitee.com/xiixiixixi/picgo/raw/master/img/IMG_1709.JPG" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://xiixiixixi.github.io/post/hello-gridea/</id>
        <link href="https://xiixiixixi.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>